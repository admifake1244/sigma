<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA 6 - Tốc Độ Cao & Tông Xe Gây Va Chạm NPC 3D (Bắn Chết NPC)</title>
    <!-- Tải Tailwind CSS cho giao diện người dùng -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tải thư viện Three.js cho đồ họa 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <!-- Giao diện người dùng (HUD và Điều khiển) -->
    <div id="ui-container" class="absolute top-4 left-4 z-10 pointer-events-none">
        <div class="bg-gray-900 bg-opacity-80 p-3 rounded-lg shadow-2xl max-w-xs pointer-events-auto text-xs text-gray-200">
            <h1 class="text-base font-bold text-red-500 mb-1">Mô Phỏng GTA 3D</h1>
            
            <div class="space-y-1">
                <p><span class="font-semibold text-yellow-400">Di chuyển:</span> <kbd class="bg-gray-700 text-white p-0.5 rounded">W/S</kbd>, <kbd class="bg-gray-700 text-white p-0.5 rounded">A/D</kbd></p>
                <p><span class="font-semibold text-pink-400">Chạy nhanh:</span> Giữ <kbd class="bg-gray-700 text-white p-0.5 rounded">Shift</kbd></p>
                <p><span class="font-semibold text-green-400">Nhảy:</span> <kbd class="bg-green-700 text-white p-0.5 rounded">Space</kbd></p>
                <p><span class="font-semibold text-yellow-400">Tấn công:</span> <kbd class="bg-gray-700 text-white p-0.5 rounded">Chuột Trái</kbd></p>
                <p><span class="font-semibold text-yellow-400">Lái xe:</span> <kbd class="bg-gray-700 text-white p-0.5 rounded">W/A/S/D</kbd></p>
                <p><span class="font-semibold text-cyan-400">Tương tác:</span> <kbd class="bg-green-600 text-white p-0.5 rounded">E</kbd> (Ra/Vào Xe)</p>
            </div>
            
            <div id="status-message" class="mt-2 p-1 bg-blue-900 bg-opacity-70 text-white rounded font-mono text-xs">
                Trạng thái: ĐI BỘ
            </div>
            <div id="interaction-prompt" class="mt-1 p-1 bg-yellow-600 text-black text-center rounded hidden">
                Nhấn [E] để lên xe.
            </div>
        </div>
    </div>

    <script>
        // --- Cài đặt Three.js ---
        let scene, camera, renderer;
        let playerCharacter, car;
        let keys = {};
        let isDriving = false;

        // Các mảng chứa vật thể
        let staticObjects = []; // Tòa nhà, nước biển, vật thể bãi biển
        let movingTraffic = []; // Xe AI
        let movingNPCs = []; // Người đi bộ AI
        
        // Raycaster và Shooting
        let raycaster;
        let gunMesh;
        
        // Kích thước bản đồ (400x400)
        const MAP_SIZE = 400; 
        const BULLET_DURATION = 100; // Thời gian hiển thị viên đạn (ms)

        // Vận tốc và hằng số
        const PLAYER_SPEED = 0.1; 
        const PLAYER_RUN_MULTIPLIER = 3.0; 
        const PLAYER_ROTATION_SPEED = 0.05; 
        
        // Constants for Jumping/Physics
        const GRAVITY = -0.05; 
        const JUMP_FORCE = 0.4; 
        
        // State for Jumping
        let yVelocity = 0; 
        let isGrounded = true; 
        
        // Chiều cao thân hộp mới (1.2 / 2 = 0.6)
        const PLAYER_GROUND_Y = 0.6; 
        
        const CAR_ACCELERATION = 0.06; 
        const CAR_ROTATION_SPEED = 0.03; 
        const CAR_FRICTION = 0.96;
        const MAX_CAR_SPEED = 0.8; 
        
        const ENTRY_DISTANCE = 3.0; 

        const NPC_SPEED = 0.05; 
        const TRAFFIC_SPEED_BASE = 0.15; 
        
        let playerVelocity = new THREE.Vector3();
        let carVelocity = new THREE.Vector3();

        // --- Hàm Khởi tạo ---
        function init() {
            // 1. Scene, Camera, Renderer
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333344); // Màu nền
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            renderer.shadowMap.enabled = true; // Bật đổ bóng
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            
            raycaster = new THREE.Raycaster();

            // 2. Tạo các đối tượng
            car = createCar(); // Xe của người chơi
            playerCharacter = createPlayerCharacter(); // Nhân vật người chơi (thân hình hộp)
            
            // Vị trí khởi đầu an toàn (Y = 0.6)
            playerCharacter.position.set(-53, PLAYER_GROUND_Y, -50); 
            car.position.set(-50, 0.25, -50); 

            // 3. Xây dựng Bản đồ, Tòa nhà, Bãi biển và NPC/Traffic
            createCityMap();

            // 4. Ánh sáng
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(200, 200, 200);
            directionalLight.castShadow = true; 
            
            // Cấu hình bóng đổ
            directionalLight.shadow.mapSize.width = 2048;  
            directionalLight.shadow.mapSize.height = 2048; 
            directionalLight.shadow.camera.near = 0.5;    
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -300;
            directionalLight.shadow.camera.right = 300;
            directionalLight.shadow.camera.top = 300;
            directionalLight.shadow.camera.bottom = -300;
            
            scene.add(directionalLight);
            
            // 5. Xử lý sự kiện
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousedown', onMouseDown, false); // Sự kiện bắn
            
            // Cài đặt camera ban đầu theo dõi nhân vật đi bộ
            updateCamera(playerCharacter);
        }

        function createCar() {
            // Thân xe (Box: rộng, cao, dài)
            const carGeometry = new THREE.BoxGeometry(2, 0.5, 4);
            const carMaterial = new THREE.MeshPhongMaterial({ color: 0xcc0000 }); // Đỏ (Player Car)
            const carMesh = new THREE.Mesh(carGeometry, carMaterial);
            carMesh.position.y = 0.25;
            carMesh.castShadow = true;
            carMesh.receiveShadow = true;
            // Thêm thuộc tính nhận dạng
            carMesh.userData.isVehicle = true; 
            scene.add(carMesh);
            return carMesh;
        }

        function createPlayerCharacter() {
            // Đầu (Sphere - Màu da)
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xf5c3a3 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            // Vị trí đầu: Body top (1.2) + Head radius (0.3) + Gap (0.1) = 1.6
            head.position.y = 1.6; 
            head.castShadow = true;

            // Thân (BOX) - Đã thay đổi: rộng 1.0, cao 1.2, sâu 1.0
            const bodyGeometry = new THREE.BoxGeometry(1.0, 1.2, 1.0); 
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 }); // Xanh lá (Áo người chơi)
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = PLAYER_GROUND_Y; // Nửa chiều cao 1.2 / 2 = 0.6
            body.castShadow = true;

            // Súng (Box nhỏ)
            const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
            const gunMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            gunMesh = new THREE.Mesh(gunGeometry, gunMaterial);
            gunMesh.position.set(0.5, 0.3, 0.5); // Offset so với trung tâm Group (tay phải)
            gunMesh.castShadow = true;

            // Group nhân vật
            const playerGroup = new THREE.Group();
            playerGroup.add(body);
            playerGroup.add(head); 
            playerGroup.add(gunMesh);
            playerGroup.rotation.order = 'YXZ'; 
            playerGroup.userData.isPlayer = true; // Thêm nhận dạng người chơi
            
            scene.add(playerGroup);
            return playerGroup;
        }

        /**
         * Sinh ra một màu ngẫu nhiên, loại trừ các màu quá trắng hoặc quá đen.
         * @returns {number} Mã màu hex của Three.js.
         */
        function getRandomNPCColor() {
            let color;
            do {
                color = new THREE.Color(Math.random(), Math.random(), Math.random());
                // Kiểm tra độ sáng: tránh màu quá trắng ( > 0.8) hoặc quá đen ( < 0.2)
                const luminance = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;
                if (luminance > 0.2 && luminance < 0.8) {
                    return color.getHex();
                }
            } while (true);
        }
        
        function createTrafficCar(color) {
            // Xe AI (Traffic)
            const carGeometry = new THREE.BoxGeometry(2, 0.5, 4);
            const carMaterial = new THREE.MeshPhongMaterial({ color: color });
            const carMesh = new THREE.Mesh(carGeometry, carMaterial);
            carMesh.position.y = 0.25;
            carMesh.castShadow = true;
            carMesh.receiveShadow = true;
            // Thêm thuộc tính nhận dạng
            carMesh.userData.isVehicle = true; 
            carMesh.velocity = new THREE.Vector3(0, 0, 0); 
            carMesh.aiState = { 
                timer: 0, 
                maxTime: Math.random() * 300 + 100,
                isReversing: false, 
                reverseTimer: 0 
            };
            scene.add(carMesh);
            return carMesh;
        }

        // Đã cập nhật để bao gồm Head Mesh (Đầu) và Body Mesh (Box)
        function createMovingNPC(customColor) {
            const bodyColor = customColor || getRandomNPCColor(); // Sử dụng màu ngẫu nhiên nếu không truyền vào
            
            // Đầu (Sphere - Màu da)
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xf5c3a3 }); 
            const head = new THREE.Mesh(headGeometry, headMaterial);
            // Vị trí đầu: Body top (1.2) + Head radius (0.3) + Gap (0.1) = 1.6
            head.position.y = 1.6; 
            head.castShadow = true;

            // Thân (BOX) - Đã thay đổi: rộng 1.0, cao 1.2, sâu 1.0
            const bodyGeometry = new THREE.BoxGeometry(1.0, 1.2, 1.0); 
            // Sử dụng màu ngẫu nhiên cho áo quần NPC
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: bodyColor }); 
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = PLAYER_GROUND_Y; // Nửa chiều cao 1.2 / 2 = 0.6
            body.castShadow = true;

            const npcGroup = new THREE.Group();
            npcGroup.add(body);
            npcGroup.add(head); // Đã thêm đầu
            
            // Thuộc tính AI và nhận dạng
            npcGroup.userData.isNPC = true; 
            npcGroup.velocity = new THREE.Vector3(0, 0, 0);
            npcGroup.aiState = { 
                walking: true, 
                turnTimer: 0, 
                turnInterval: Math.floor(Math.random() * 200) + 100 
            };
            
            scene.add(npcGroup);
            return npcGroup;
        }
        
        // --- Hàm tạo vật thể bãi biển ---
        function createPalmTree() {
            const tree = new THREE.Group();
            
            // Thân cây (Màu nâu)
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 6, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 }); 
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3; 
            trunk.castShadow = true;
            tree.add(trunk);

            // Lá (Màu xanh, hình nón đơn giản)
            const leavesGeometry = new THREE.ConeGeometry(3, 3, 8);
            const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 }); 
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 7;
            leaves.castShadow = true;
            tree.add(leaves);
            
            scene.add(tree);
            return tree;
        }

        function createSunLounger(color) {
            const lounger = new THREE.Group();
            
            // Khung (Màu gỗ)
            const frameGeometry = new THREE.BoxGeometry(0.5, 0.2, 3);
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0xa0522d }); 
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = 0.1;
            frame.castShadow = true;
            lounger.add(frame);

            // Vải (Phần tựa lưng, nâng lên 30 độ)
            const backGeometry = new THREE.BoxGeometry(0.5, 0.1, 1.5);
            const backMaterial = new THREE.MeshPhongMaterial({ color: color });
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.set(0, 0.25, -0.75);
            back.rotation.x = Math.PI / 6; // Nghiêng 30 độ
            back.castShadow = true;
            lounger.add(back);
            
            // Vải (Phần ngồi)
            const seatGeometry = new THREE.BoxGeometry(0.5, 0.1, 1.5);
            const seatMaterial = new THREE.MeshPhongMaterial({ color: color });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.set(0, 0.25, 0.75);
            seat.castShadow = true;
            lounger.add(seat);
            
            scene.add(lounger);
            return lounger;
        }

        function createBeachUmbrella(color) {
            const umbrella = new THREE.Group();
            
            // Cột (Màu trắng/kim loại)
            const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 16);
            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2;
            pole.castShadow = true;
            umbrella.add(pole);

            // Tán (Màu sáng)
            const canopyGeometry = new THREE.ConeGeometry(2, 0.5, 32);
            const canopyMaterial = new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.rotation.x = Math.PI; // Lật ngược nón
            canopy.position.y = 4 + 0.25; 
            canopy.castShadow = true;
            umbrella.add(canopy);
            
            scene.add(umbrella);
            return umbrella;
        }
        
        // --- Logic Xây dựng bản đồ ---
        function createCityMap() {
            // Kích thước bãi biển (một phần tư bản đồ)
            const BEACH_SIZE = MAP_SIZE / 2; // 200
            const BEACH_END = MAP_SIZE / 2; // 200

            // Sàn (Đường - khu vực chính)
            const roadGeometry = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE);
            const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222, side: THREE.DoubleSide });
            const roads = new THREE.Mesh(roadGeometry, roadMaterial);
            roads.rotation.x = Math.PI / 2;
            roads.position.y = 0; 
            roads.receiveShadow = true;
            scene.add(roads);

            // Bãi biển (Cát - khu vực phía dưới bên phải: X>0, Z>0)
            const sandGeometry = new THREE.PlaneGeometry(BEACH_SIZE, BEACH_SIZE);
            // Màu vàng sáng/gold
            const sandMaterial = new THREE.MeshPhongMaterial({ color: 0xfcd34d, side: THREE.DoubleSide }); 
            const sand = new THREE.Mesh(sandGeometry, sandMaterial);
            sand.rotation.x = Math.PI / 2;
            sand.position.set(MAP_SIZE / 4, 0.001, MAP_SIZE / 4); // Đặt cao hơn 0.001 để đảm bảo hiển thị
            sand.receiveShadow = true;
            scene.add(sand);

            // Đại dương (Nước biển - khu vực bên ngoài)
            const oceanGeometry = new THREE.PlaneGeometry(MAP_SIZE * 2, MAP_SIZE * 2);
            const oceanMaterial = new THREE.MeshPhongMaterial({ color: 0x0077be, opacity: 0.8, transparent: true, side: THREE.DoubleSide });
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = Math.PI / 2;
            ocean.position.y = -0.3;
            ocean.position.x = MAP_SIZE / 2;
            ocean.position.z = MAP_SIZE / 2;
            ocean.userData.isOcean = true; // Đánh dấu là đại dương
            scene.add(ocean);
            staticObjects.push(ocean); 

            // --- TẠO TÒA NHÀ (CHỈ Ở THÀNH PHỐ: NGOÀI KHU VỰC CÁT) ---
            const NUM_BUILDINGS = 300; 
            for (let i = 0; i < NUM_BUILDINGS; i++) {
                const height = Math.random() * 10 + 3;
                const size = Math.random() * 4 + 1.5;
                const buildingGeometry = new THREE.BoxGeometry(size, height, size);
                
                const buildingColor = new THREE.Color(
                    Math.random() * 0.4 + 0.2, 
                    Math.random() * 0.4 + 0.2, 
                    Math.random() * 0.4 + 0.2
                );
                const buildingMaterial = new THREE.MeshPhongMaterial({ color: buildingColor });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

                let buildingX, buildingZ;
                let isInsideBeach;

                do {
                    // Sinh ngẫu nhiên trong phạm vi bản đồ chính
                    buildingX = (Math.random() - 0.5) * (MAP_SIZE - 20); // Phạm vi rộng hơn
                    buildingZ = (Math.random() - 0.5) * (MAP_SIZE - 20);
                    
                    // Kiểm tra xem vị trí có nằm trong bãi cát [0, 200] x [0, 200] không
                    isInsideBeach = buildingX >= 0 && buildingX <= BEACH_END && 
                                    buildingZ >= 0 && buildingZ <= BEACH_END;

                } while (isInsideBeach); // Lặp lại nếu nằm trong khu vực bãi cát

                building.position.x = buildingX;
                building.position.z = buildingZ;
                building.position.y = height / 2;
                building.userData.isBuilding = true; // Đánh dấu là tòa nhà
                building.castShadow = true;
                building.receiveShadow = true;

                scene.add(building);
                staticObjects.push(building); 
            }
            
            // --- Thêm Cảnh Vật Bãi Biển (Cây dừa, Ghế, Dù) ---
            const BEACH_OBJECT_COUNT = 50; 

            for (let i = 0; i < BEACH_OBJECT_COUNT; i++) {
                const type = Math.floor(Math.random() * 3); // 0: Dừa, 1: Ghế, 2: Dù

                // Vị trí ngẫu nhiên trong phạm vi bãi cát (X: 0->BEACH_SIZE, Z: 0->BEACH_SIZE)
                const x = Math.random() * (BEACH_SIZE - 10) + 5;
                const z = Math.random() * (BEACH_SIZE - 10) + 5;

                let object;
                let yPos = 0.01; // Cao hơn cát một chút (0.01)
                const randomColor = new THREE.Color(Math.random(), Math.random(), Math.random());

                if (type === 0) {
                    // Cây dừa
                    object = createPalmTree();
                    object.userData.isTree = true;
                } else if (type === 1) {
                    // Ghế tắm nắng
                    object = createSunLounger(randomColor);
                    object.rotation.y = Math.random() * Math.PI * 2; // Xoay ngẫu nhiên
                    object.userData.isLounger = true;
                } else {
                    // Dù
                    object = createBeachUmbrella(randomColor);
                    object.userData.isUmbrella = true;
                }
                
                object.position.set(x, yPos, z);
                staticObjects.push(object);
            }

            // --- Logic Sinh Vật Thể (Traffic và NPC) ---
            const NUM_TRAFFIC = 40; 
            const NUM_NPCS = 80;    
            
            // 1. Thêm các xe cộ NPC (Moving Traffic) - CHỈ TRONG THÀNH PHỐ
            
            // Khởi tạo một mesh tạm thời để kiểm tra va chạm tại vị trí spawn
            const tempCarGeometry = new THREE.BoxGeometry(2, 0.5, 4);
            const tempCarMaterial = new THREE.MeshBasicMaterial();
            const tempCarChecker = new THREE.Mesh(tempCarGeometry, tempCarMaterial);
            const carSpawnBuffer = 1.0; // Vùng đệm xung quanh xe để tránh dính sát vào tường

            for (let i = 0; i < NUM_TRAFFIC; i++) {
                let carX, carZ;
                let isInsideBeachOrBuilding;
                
                do {
                    // 1. Sinh ngẫu nhiên trong phạm vi bản đồ chính
                    carX = (Math.random() - 0.5) * (MAP_SIZE - 40);
                    carZ = (Math.random() - 0.5) * (MAP_SIZE - 40);
                    
                    // 2. Kiểm tra Bãi biển
                    let isInsideBeach = carX >= 0 && carZ >= 0 && carX <= BEACH_END && carZ <= BEACH_END;
                    
                    // 3. Kiểm tra Va chạm với Tòa nhà
                    let isOverlappingBuilding = false;
                    tempCarChecker.position.set(carX, 0.25, carZ); // Đặt mesh tạm thời tại vị trí spawn
                    tempCarChecker.updateMatrixWorld(true);
                    // Tạo Bounding Box cho vị trí spawn (bao gồm cả buffer)
                    const trafficSpawnBox = new THREE.Box3().setFromObject(tempCarChecker).expandByScalar(carSpawnBuffer); 

                    for (const object of staticObjects) {
                        // Chỉ kiểm tra đối với các vật thể có BoxGeometry (tòa nhà)
                        if (object.userData.isBuilding) { 
                            const objectBox = new THREE.Box3().setFromObject(object);
                            if (trafficSpawnBox.intersectsBox(objectBox)) {
                                isOverlappingBuilding = true;
                                break;
                            }
                        }
                    }

                    isInsideBeachOrBuilding = isInsideBeach || isOverlappingBuilding;

                } while (isInsideBeachOrBuilding);

                // 4. Sinh xe thực tế sau khi tìm được vị trí an toàn
                const trafficCar = createTrafficCar(0x0000ff); 
                trafficCar.position.x = carX;
                trafficCar.position.z = carZ;
                trafficCar.rotation.y = Math.random() * Math.PI * 2;
                movingTraffic.push(trafficCar);
            }
            
            // Dọn dẹp mesh tạm thời
            tempCarGeometry.dispose();
            tempCarMaterial.dispose(); 


            // 2. Thêm các NPC đi bộ (Moving Pedestrians) - TẬP TRUNG Ở BÃI CÁT (70%)
            const BEACH_NPC_COUNT = Math.floor(NUM_NPCS * 0.7); 
            const CITY_NPC_COUNT = NUM_NPCS - BEACH_NPC_COUNT; 
            
            // Spawn 70% trong khu vực Bãi cát [0, BEACH_END] x [0, BEACH_END]
            for (let i = 0; i < BEACH_NPC_COUNT; i++) {
                // Gọi createMovingNPC không truyền màu để lấy màu ngẫu nhiên (có đầu, thân hộp)
                const npc = createMovingNPC(); 
                npc.position.x = Math.random() * BEACH_END; 
                npc.position.z = Math.random() * BEACH_END;
                npc.rotation.y = Math.random() * Math.PI * 2;
                movingNPCs.push(npc);
            }

            // Spawn 30% trong khu vực Thành phố (bên ngoài bãi cát)
            for (let i = 0; i < CITY_NPC_COUNT; i++) {
                let npcX, npcZ;
                let isInsideBeach;

                do {
                    // Sinh ngẫu nhiên trong phạm vi bản đồ chính
                    npcX = (Math.random() - 0.5) * (MAP_SIZE - 40);
                    npcZ = (Math.random() - 0.5) * (MAP_SIZE - 40);
                    // Kiểm tra xem vị trí có nằm trong bãi cát [0, 200] x [0, 200] không
                    isInsideBeach = npcX >= 0 && npcX <= BEACH_END && npcZ >= 0 && npcZ <= BEACH_END;
                } while (isInsideBeach);


                // Gọi createMovingNPC không truyền màu để lấy màu ngẫu nhiên (có đầu, thân hộp)
                const npc = createMovingNPC(); 
                npc.position.x = npcX;
                npc.position.z = npcZ;
                npc.rotation.y = Math.random() * Math.PI * 2;
                movingNPCs.push(npc);
            }
        }
        
        // --- Xử lý sự kiện phím và chuột ---
        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;

            // Xử lý tương tác 'E'
            if (event.key.toLowerCase() === 'e') {
                if (isDriving) {
                    exitCar();
                } else {
                    const distance = playerCharacter.position.distanceTo(car.position);
                    if (distance <= ENTRY_DISTANCE) {
                        enterCar();
                    }
                }
            }
            
            // Xử lý nhảy 'Spacebar'
            if (!isDriving && event.key.toLowerCase() === ' ') {
                if (isGrounded) {
                    yVelocity = JUMP_FORCE;
                    isGrounded = false;
                }
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        function onMouseDown(event) {
            if (isDriving || event.button !== 0) return; // Chỉ bắn khi đi bộ và nhấn chuột trái

            // 1. Tính toán hướng bắn (sử dụng hướng nhìn của nhân vật)
            const direction = new THREE.Vector3(0, 0, 1);
            direction.applyQuaternion(playerCharacter.quaternion);

            const origin = playerCharacter.position.clone();
            // Điều chỉnh origin Y lên 1.5 để nhắm vào thân/đầu của NPC (NPC body center Y=0.6, top Y=1.2, head center Y=1.6)
            origin.y += 1.5; 

            raycaster.set(origin, direction);

            // 2. Tìm kiếm va chạm với NPC
            // Cần lấy tất cả các mesh (Body và Head) của NPC để raycast
            const npcMeshes = movingNPCs.flatMap(npc => npc.children); 
            const intersects = raycaster.intersectObjects(npcMeshes, true);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                // Parent của hitMesh phải là THREE.Group của NPC
                let targetNPC = hitMesh.parent; 

                // Đảm bảo targetNPC là một NPC đang di chuyển hợp lệ
                if (targetNPC.userData.isNPC) {
                    // Loại bỏ NPC bị bắn
                    scene.remove(targetNPC);
                    // Xóa khỏi mảng theo dõi
                    movingNPCs.splice(movingNPCs.indexOf(targetNPC), 1);
                    console.log('NPC bị bắn và đã bị loại bỏ!');
                }
            }

            // 3. Hiệu ứng viên đạn (đường thẳng đơn giản)
            const bulletGeometry = new THREE.BoxGeometry(0.1, 0.1, 50);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Đặt vị trí và xoay viên đạn theo ray
            bullet.position.copy(origin);
            bullet.lookAt(origin.clone().add(direction));
            bullet.translateZ(25); 
            
            scene.add(bullet);

            // Loại bỏ viên đạn sau thời gian ngắn
            setTimeout(() => {
                scene.remove(bullet);
            }, BULLET_DURATION); 
        }

        // --- Logic Lên/Xuống Xe ---
        function enterCar() {
            isDriving = true;
            
            playerCharacter.visible = false;
            // Đảm bảo nhân vật ở vị trí của xe để camera không nhảy khi ra/vào
            playerCharacter.position.copy(car.position); 

            carVelocity.set(0, 0, 0);

            document.getElementById('status-message').textContent = 'Trạng thái: LÁI XE';
            document.getElementById('interaction-prompt').classList.add('hidden');
        }

        function exitCar() {
            isDriving = false;
            
            // Đặt nhân vật ở bên trái xe
            const offset = new THREE.Vector3(-3, 0, 0); 
            offset.applyQuaternion(car.quaternion); 
            
            playerCharacter.position.copy(car.position).add(offset);
            playerCharacter.position.y = PLAYER_GROUND_Y; // Đảm bảo người chơi luôn trên mặt đất khi ra xe (0.6)
            
            // Đặt lại trạng thái vật lý khi ra xe
            yVelocity = 0;
            isGrounded = true;

            playerCharacter.visible = true;

            carVelocity.set(0, 0, 0);

            document.getElementById('status-message').textContent = 'Trạng thái: ĐI BỘ';
        }

        // --- Hàm loại bỏ NPC bị tông (Hành vi Mới) ---
        function removeNPC(npc) {
            if (npc.userData.isNPC) {
                scene.remove(npc);
                const index = movingNPCs.indexOf(npc);
                if (index > -1) {
                    movingNPCs.splice(index, 1);
                    console.log('NPC bị tông và đã bị loại bỏ!');
                }
            }
        }
        
        // --- AI và Cập nhật Chuyển động của NPC ---
        function updateMovingNPCs() {
            // Bao gồm tất cả các vật thể va chạm: Tòa nhà, Xe traffic, NPC khác, Xe người chơi, Vật thể bãi biển
            const allCollidables = [...staticObjects, ...movingTraffic, car]; 
            
            movingNPCs.forEach(npc => {
                // Giữ NPC ở độ cao đi bộ
                if (npc.position.y < PLAYER_GROUND_Y) npc.position.y = PLAYER_GROUND_Y; // Y = 0.6

                // 1. Tính toán hướng di chuyển
                const direction = new THREE.Vector3(0, 0, 1);
                direction.applyQuaternion(npc.quaternion);
                
                // Vận tốc di chuyển
                const step = direction.multiplyScalar(NPC_SPEED);
                
                let collisionDetected = false;
                
                // 2. Tính toán Box va chạm (sử dụng Box 1.2x1.2x1.2 cho NPC)
                const npcCollisionBox = new THREE.Box3();
                const tempNPC = npc.clone(); 
                
                // Kích thước Box va chạm mới
                const NPC_COLLISION_SIZE = new THREE.Vector3(1.2, 1.2, 1.2); 

                const checkCollision = (futurePosition) => {
                    tempNPC.position.copy(futurePosition);
                    tempNPC.updateMatrixWorld(true);

                    // Box va chạm của NPC (Kích thước mới: 1.2 x 1.2 x 1.2)
                    npcCollisionBox.setFromCenterAndSize(
                        futurePosition.clone().setY(PLAYER_GROUND_Y), // Center Y = 0.6
                        NPC_COLLISION_SIZE 
                    ); 
                    
                    for (const object of allCollidables) {
                        if (object === npc || object.userData.isPlayer) continue; // Bỏ qua chính NPC và Player

                        let objectBox = new THREE.Box3();
                        
                        // Kiểm tra va chạm với xe (traffic hoặc player)
                        if (object.userData.isVehicle) {
                            objectBox.setFromObject(object);
                            if (npcCollisionBox.intersectsBox(objectBox)) {
                                // VA CHẠM XE VỚI NPC: Loại bỏ NPC
                                removeNPC(npc);
                                return true; // Va chạm và đã xử lý
                            }
                        } 
                        // Kiểm tra va chạm với vật thể tĩnh
                        else {
                            objectBox.setFromObject(object);
                            // Bỏ qua Sàn và Cát (PlaneGeometry)
                            if (object.geometry && object.geometry.type === 'PlaneGeometry') continue; 
                            
                            if (npcCollisionBox.intersectsBox(objectBox)) {
                                return true; // Va chạm với tường/cây
                            }
                        }
                    }
                    return false; // Không va chạm
                };


                let futurePosition = npc.position.clone();
                futurePosition.add(step);

                if (checkCollision(futurePosition)) {
                    collisionDetected = true;
                }
                
                // Va chạm với vật thể tĩnh/chướng ngại vật (Không phải xe)
                if (collisionDetected) {
                    // Va chạm: Buộc NPC quay đầu 180 độ
                    npc.rotation.y += Math.PI; 
                    npc.aiState.turnTimer = 0; 
                } else {
                    // Không va chạm: Di chuyển
                    npc.position.copy(futurePosition);
                }

                // Logic xoay ngẫu nhiên
                npc.aiState.turnTimer++;
                
                if (npc.aiState.turnTimer > npc.aiState.turnInterval) {
                    // Xoay ngẫu nhiên nhẹ (để không đi thẳng mãi)
                    const rotationAmount = (Math.random() - 0.5) * 0.5; 
                    npc.rotation.y += rotationAmount;
                    npc.aiState.turnTimer = 0;
                    npc.aiState.turnInterval = Math.floor(Math.random() * 200) + 100;
                }
            });
        }

        // --- AI và Cập nhật Chuyển động của Xe cộ Giao thông ---
        function updateMovingTraffic() {
            // Vật thể va chạm cho xe traffic: Tòa nhà, Đại dương, Xe người chơi, Vật thể bãi biển
            const allStaticAndPlayerCar = [...staticObjects, car]; 
            
            movingTraffic.forEach(trafficCar => {
                // --- Xử lý Lùi xe khi va chạm ---
                if (trafficCar.aiState.isReversing) {
                    if (trafficCar.aiState.reverseTimer > 0) {
                        trafficCar.translateZ(-TRAFFIC_SPEED_BASE * 0.5); 
                        trafficCar.aiState.reverseTimer--;
                    } else {
                        trafficCar.aiState.isReversing = false;
                        // Sau khi lùi, quay đầu ngay lập tức để tránh obstacle
                        const turnAmount = Math.random() > 0.5 ? Math.PI / 2 : -Math.PI / 2;
                        trafficCar.rotation.y += turnAmount; 
                        trafficCar.aiState.timer = 0; 
                    }
                    return; 
                }
                // --- Kết thúc Xử lý Lùi xe ---

                // 1. Lấy hướng di chuyển hiện tại
                const direction = new THREE.Vector3(0, 0, 1);
                direction.applyQuaternion(trafficCar.quaternion);
                
                // 2. Tính toán vị trí tương lai (Tiến)
                let futurePosition = trafficCar.position.clone().add(direction.multiplyScalar(TRAFFIC_SPEED_BASE));
                
                let collisionDetected = false;
                
                // Tạo một Box3 cho vị trí tương lai của xe AI
                const tempCar = trafficCar.clone();
                tempCar.position.copy(futurePosition);
                tempCar.updateMatrixWorld(true);
                const trafficFutureBox = new THREE.Box3().setFromObject(tempCar).expandByScalar(0.2);

                // KIỂM TRA VA CHẠM XE AI VỚI NPC 
                for (let i = 0; i < movingNPCs.length; i++) {
                    const npc = movingNPCs[i];
                    // Tạo một Box3 cho NPC (Body - BoxGeometry)
                    const npcBody = npc.children.find(child => child.geometry.type === 'BoxGeometry'); 
                    const npcBox = new THREE.Box3().setFromObject(npcBody).expandByVector(new THREE.Vector3(0.1, 0.1, 0.1));
                    
                    if (trafficFutureBox.intersectsBox(npcBox)) {
                        // Xe AI tông vào NPC -> Loại bỏ NPC
                        removeNPC(npc); 
                        // Xe AI không cần dừng lại, tiếp tục kiểm tra va chạm khác
                    }
                }

                // KIỂM TRA VA CHẠM XE AI VỚI MÔI TRƯỜNG VÀ XE KHÁC
                for (const object of allStaticAndPlayerCar) {
                    if (object === trafficCar) continue; 

                    const objectBox = new THREE.Box3().setFromObject(object);

                    if (trafficFutureBox.intersectsBox(objectBox)) {
                        collisionDetected = true;
                        break;
                    }
                }
                
                if (collisionDetected) {
                    // Va chạm: Kích hoạt chế độ lùi
                    trafficCar.aiState.isReversing = true;
                    trafficCar.aiState.reverseTimer = 30; 
                    trafficCar.aiState.timer = 0; 
                } else {
                    // Không va chạm: Di chuyển
                    trafficCar.position.copy(futurePosition);

                    // Logic rẽ ngẫu nhiên
                    trafficCar.aiState.timer++;
                    if (trafficCar.aiState.timer > trafficCar.aiState.maxTime) {
                        const turnDirection = Math.random() > 0.5 ? Math.PI / 2 : -Math.PI / 2;
                        trafficCar.rotation.y += turnDirection;
                        trafficCar.aiState.timer = 0;
                        trafficCar.aiState.maxTime = Math.random() * 300 + 100; 
                    }
                }
            });
        }

        // --- Kiểm tra Va Chạm Xe Người chơi ---
        function checkCarCollision(futurePosition, futureQuaternion) {
            // 1. Tạo Box3 cho vị trí tương lai của xe người chơi
            const carBox = new THREE.Box3();
            const tempCar = car.clone();
            tempCar.position.copy(futurePosition);
            tempCar.quaternion.copy(futureQuaternion);
            tempCar.updateMatrixWorld(true);
            const playerCarFutureBox = new THREE.Box3().setFromObject(tempCar).expandByScalar(0.1);

            // Kết hợp vật thể tĩnh (Buildings, Ocean, Beach objects) và xe cộ giao thông (Moving Traffic)
            const allObstacles = [...staticObjects, ...movingTraffic]; 

            // KIỂM TRA VA CHẠM XE PLAYER VỚI NPC
            for (let i = 0; i < movingNPCs.length; i++) {
                const npc = movingNPCs[i];
                // Tạo một Box3 cho NPC
                // Lấy từ phần tử đầu tiên của Group NPC (Body - BoxGeometry)
                const npcBody = npc.children.find(child => child.geometry.type === 'BoxGeometry'); 
                const npcBox = new THREE.Box3().setFromObject(npcBody).expandByVector(new THREE.Vector3(0.1, 0.1, 0.1));
                
                if (playerCarFutureBox.intersectsBox(npcBox)) {
                    // Xe Player tông vào NPC -> Loại bỏ NPC
                    removeNPC(npc); 
                    // Xe Player không bị ảnh hưởng quá nhiều, tiếp tục kiểm tra va chạm khác
                }
            }


            // KIỂM TRA VA CHẠM XE PLAYER VỚI MÔI TRƯỜNG VÀ XE KHÁC
            for (let i = 0; i < allObstacles.length; i++) {
                const object = allObstacles[i];
                if (object === car) continue; 

                // 2. Lấy Bounding Box của vật thể tĩnh/xe giao thông
                const objectBox = new THREE.Box3().setFromObject(object);

                if (playerCarFutureBox.intersectsBox(objectBox)) {
                    return object;
                }
            }
            return null;
        }


        // --- Cập nhật logic Game ---
        function updateMovement() {
            if (isDriving) {
                updateCarMovement();
                updateCamera(car);
                gunMesh.visible = false; // Ẩn súng khi lái xe
            } else {
                updatePlayerMovement();
                updateCamera(playerCharacter);
                gunMesh.visible = true; // Hiện súng khi đi bộ
            }
        }

        function updatePlayerMovement() {
            // 1. Xác định tốc độ hiện tại (Bình thường hoặc Chạy nhanh)
            let speed = PLAYER_SPEED;
            if (keys['shift']) {
                speed *= PLAYER_RUN_MULTIPLIER;
            }

            // 2. Xử lý Xoay (A/D)
            const rotationSpeed = PLAYER_ROTATION_SPEED;
            if (keys['a']) {
                playerCharacter.rotation.y += rotationSpeed; 
            }
            if (keys['d']) {
                playerCharacter.rotation.y -= rotationSpeed; 
            }
            
            // 3. Xử lý Di chuyển (X/Z)
            let currentPosition = playerCharacter.position.clone();
            const moveDirection = new THREE.Vector3();

            if (keys['w']) {
                moveDirection.z += speed;
            }
            if (keys['s']) {
                moveDirection.z -= speed;
            }

            // Áp dụng xoay cho vector di chuyển
            moveDirection.applyQuaternion(playerCharacter.quaternion);

            // Bước 1: Di chuyển theo X
            let futureXPosition = currentPosition.clone();
            futureXPosition.x += moveDirection.x;

            if (!checkStaticCollisionForPlayer(futureXPosition)) {
                playerCharacter.position.x = futureXPosition.x;
            } 
            
            // Bước 2: Di chuyển theo Z (sử dụng vị trí X đã cập nhật)
            let futureZPosition = playerCharacter.position.clone(); 
            futureZPosition.z += moveDirection.z;

            if (!checkStaticCollisionForPlayer(futureZPosition)) {
                playerCharacter.position.z = futureZPosition.z;
            } 

            // 4. Xử lý Nhảy và Trọng lực (Y-axis Physics)
            if (!isGrounded) {
                yVelocity += GRAVITY; 
            }

            let futureYPosition = playerCharacter.position.y + yVelocity;

            // Kiểm tra va chạm với mặt đất (ground level = 0.6)
            if (futureYPosition <= PLAYER_GROUND_Y) { 
                futureYPosition = PLAYER_GROUND_Y; 
                if (!isGrounded) {
                    isGrounded = true;
                    yVelocity = 0;
                }
            } else {
                 isGrounded = false; // Đang ở giữa không trung (hoặc đang nhảy)
            }

            // Áp dụng vị trí Y
            playerCharacter.position.y = futureYPosition;
            
            // 5. Kiểm tra tương tác với xe
            const distance = playerCharacter.position.distanceTo(car.position);
            const prompt = document.getElementById('interaction-prompt');
            const statusMessage = document.getElementById('status-message');

            if (distance <= ENTRY_DISTANCE) {
                prompt.classList.remove('hidden');
            } else {
                prompt.classList.add('hidden');
            }
            
            // Cập nhật HUD
            statusMessage.textContent = isDriving ? 'Trạng thái: LÁI XE' : 
                                       (isGrounded ? (keys['shift'] ? 'Trạng thái: CHẠY' : 'Trạng thái: ĐI BỘ') : 'Trạng thái: NHẢY / RƠI');

        }

        /**
         * Kiểm tra va chạm AABB giữa người chơi tại vị trí tương lai và các vật thể tĩnh.
         * @param {THREE.Vector3} futurePosition Vị trí người chơi muốn đến.
         * @returns {boolean} True nếu có va chạm.
         */
        function checkStaticCollisionForPlayer(futurePosition) {
            // Box va chạm của người chơi (Kích thước mới: 1.2 x 1.2 x 1.2)
            const playerCollisionBox = new THREE.Box3().setFromCenterAndSize(
                futurePosition.clone().setY(playerCharacter.position.y), // Sử dụng Y hiện tại/tương lai
                new THREE.Vector3(1.2, 1.2, 1.2) 
            ); 
            
            for (const object of staticObjects) {
                let objectBox = new THREE.Box3();
                
                // Bỏ qua Sàn và Cát (PlaneGeometry)
                if (object.geometry && object.geometry.type === 'PlaneGeometry') continue; 

                
                // Tính toán Box cho vật thể tĩnh
                if (object.geometry) {
                    objectBox.setFromObject(object);
                } else if (object.children.length > 0) {
                    // Dành cho các Group như cây dừa, ghế
                    objectBox.setFromObject(object);
                } else {
                    continue; 
                }
                
                if (playerCollisionBox.intersectsBox(objectBox)) {
                    return true; // Va chạm detected
                }
            }
            return false;
        }

        function updateCarMovement() {
            // 1. Tính toán Xoay xe tương lai
            let nextRotationY = car.rotation.y;
            if (keys['a']) {
                nextRotationY += CAR_ROTATION_SPEED;
            }
            if (keys['d']) {
                nextRotationY -= CAR_ROTATION_SPEED;
            }

            // 2. Tính toán Vận tốc mới
            let direction = new THREE.Vector3(0, 0, 1);
            const tempQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), nextRotationY);
            direction.applyQuaternion(tempQuaternion);

            let newCarVelocity = carVelocity.clone();
            if (keys['w']) {
                newCarVelocity.add(direction.multiplyScalar(CAR_ACCELERATION));
            } else if (keys['s']) {
                newCarVelocity.add(direction.multiplyScalar(-CAR_ACCELERATION / 2));
            }

            // 3. Áp dụng ma sát và giới hạn tốc độ
            newCarVelocity.multiplyScalar(CAR_FRICTION);
            if (newCarVelocity.length() > MAX_CAR_SPEED) {
                newCarVelocity.normalize().multiplyScalar(MAX_CAR_SPEED);
            }
            
            // 4. Tính toán vị trí tương lai
            let futurePosition = car.position.clone().add(newCarVelocity);

            // 5. KIỂM TRA VA CHẠM
            const collisionObject = checkCarCollision(futurePosition, tempQuaternion);

            if (collisionObject) {
                // VA CHẠM XẢY RA: Đẩy lùi mạnh hơn
                carVelocity.multiplyScalar(-0.5); 
                // Giữ vị trí cũ (ngăn chuyển động vào vật thể)
                car.position.copy(car.position); 
            } else {
                // KHÔNG VA CHẠM: Áp dụng chuyển động
                car.rotation.y = nextRotationY;
                car.position.copy(futurePosition);
                carVelocity.copy(newCarVelocity);
            }
            
            // 6. Giữ nhân vật luôn đồng bộ với xe khi lái
            playerCharacter.position.copy(car.position);
        }

        function updateCamera(target) {
            // Camera theo dõi (offset ra phía sau mục tiêu)
            const relativeCameraOffset = new THREE.Vector3(0, 5, -8); 
            const cameraOffset = relativeCameraOffset.applyMatrix4(target.matrixWorld);

            camera.position.lerp(cameraOffset, 0.15); // Di chuyển mượt mà hơn
            camera.lookAt(target.position);
        }

        // --- Game Loop (Vòng lặp hoạt hình) ---
        function animate() {
            requestAnimationFrame(animate);

            updateMovement();
            updateMovingNPCs(); 
            updateMovingTraffic(); 
            
            renderer.render(scene, camera);
        }

        // --- Xử lý thay đổi kích thước cửa sổ ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Khởi động Game ---
        window.onload = function () {
            init();
            animate();
        };

    </script>
</body>
</html>